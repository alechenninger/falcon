syntax = "proto3";

package falcon.graph;

option go_package = "github.com/alechenninger/falcon/graph/proto;graphpb";

// GraphService provides cross-node graph query operations.
// These RPCs mirror the Graph interface methods for distributed execution.
service GraphService {
  // Check determines if a subject has a relation on an object within a snapshot window.
  // This is called when traversing arrows or userset subjects that point to objects
  // on different shards.
  rpc Check(CheckRequest) returns (CheckResponse);

  // CheckUnion checks if a subject has a relation on any of the given objects.
  // This is used for scatter-gather: the caller groups objects by destination node,
  // then calls this RPC once per node with all relevant objects.
  // Returns true if the subject has the relation on ANY of the objects (short-circuits).
  // Each RelationCheck has its own snapshot window for independent narrowing.
  rpc CheckUnion(CheckUnionRequest) returns (CheckUnionResponse);
}

// SnapshotWindow represents the time range for consistent snapshot reads.
// As queries traverse the graph, the window narrows to ensure consistency.
message SnapshotWindow {
  // min is the minimum store time we've committed to (state we've already used).
  uint64 min = 1;
  // max is the maximum store time we can use (replicated time ceiling).
  uint64 max = 2;
}

// VisitedNode represents an (object_type, object_id, relation) triple that
// has already been visited in the current query traversal.
// Used for cycle detection across distributed nodes.
message VisitedNode {
  string object_type = 1;
  uint32 object_id = 2;
  string relation = 3;
}

// CheckRequest is the request to check if a subject has a relation on an object.
message CheckRequest {
  string subject_type = 1;
  uint32 subject_id = 2;
  string object_type = 3;
  uint32 object_id = 4;
  string relation = 5;
  // window constrains the snapshot for consistent reads across shards.
  SnapshotWindow window = 6;
  // visited contains the nodes already visited in this query traversal.
  // Used for cycle detection across distributed nodes.
  repeated VisitedNode visited = 7;
}

// CheckResponse is the result of a relation check.
message CheckResponse {
  // allowed is true if the subject has the relation on the object.
  bool allowed = 1;
  // window is the narrowed snapshot window after the check.
  // Subsequent queries should use this to maintain consistency.
  SnapshotWindow window = 2;
}

// RelationCheck represents a check against a single object type's relation.
// Used by CheckUnion to batch multiple checks with independent windows.
message RelationCheck {
  string object_type = 1;
  // Serialized roaring bitmap of object IDs.
  bytes object_ids = 2;
  string relation = 3;
  // Per-check window, narrowed based on reading this type's data.
  SnapshotWindow window = 4;
}

// CheckUnionRequest checks if a subject has a relation on any of multiple objects.
// Each RelationCheck has its own snapshot window for independent narrowing.
message CheckUnionRequest {
  string subject_type = 1;
  uint32 subject_id = 2;
  // Checks to perform, each with its own object type, IDs, relation, and window.
  repeated RelationCheck checks = 3;
  // visited contains the nodes already visited in this query traversal.
  repeated VisitedNode visited = 4;
}

// CheckUnionResponse is the result of a union check.
message CheckUnionResponse {
  // allowed is true if the subject has the relation on ANY of the objects.
  bool allowed = 1;
  // window is the narrowed snapshot window after the check.
  // If found: window from the successful check.
  // If not found: tightest window across all checks.
  SnapshotWindow window = 2;
}
