syntax = "proto3";

package falcon.graph;

option go_package = "github.com/alechenninger/falcon/graph/proto;graphpb";

// GraphService provides cross-node graph query operations.
service GraphService {
  // CheckRelation checks if a subject has a relation on an object within a snapshot window.
  // This is called when traversing arrows or userset subjects that point to objects
  // on different shards.
  rpc CheckRelation(CheckRelationRequest) returns (CheckRelationResponse);

  // BatchCheckRelation checks if a subject has a relation on any of the given objects.
  // This is used for scatter-gather: the caller groups objects by destination node,
  // then calls this RPC once per node with all relevant objects.
  // Returns true if the subject has the relation on ANY of the objects (short-circuits).
  rpc BatchCheckRelation(BatchCheckRelationRequest) returns (BatchCheckRelationResponse);
}

// SnapshotWindow represents the time range for consistent snapshot reads.
// As queries traverse the graph, the window narrows to ensure consistency.
message SnapshotWindow {
  // min is the minimum store time we've committed to (state we've already used).
  uint64 min = 1;
  // max is the maximum store time we can use (replicated time ceiling).
  uint64 max = 2;
}

// VisitedNode represents an (object_type, object_id, relation) triple that
// has already been visited in the current query traversal.
// Used for cycle detection across distributed nodes.
message VisitedNode {
  string object_type = 1;
  uint32 object_id = 2;
  string relation = 3;
}

// CheckRelationRequest is the request to check if a subject has a relation on an object.
message CheckRelationRequest {
  string subject_type = 1;
  uint32 subject_id = 2;
  string object_type = 3;
  uint32 object_id = 4;
  string relation = 5;
  // window constrains the snapshot for consistent reads across shards.
  SnapshotWindow window = 6;
  // visited contains the nodes already visited in this query traversal.
  // Used for cycle detection across distributed nodes.
  repeated VisitedNode visited = 7;
}

// CheckRelationResponse is the result of a relation check.
message CheckRelationResponse {
  // allowed is true if the subject has the relation on the object.
  bool allowed = 1;
  // window is the narrowed snapshot window after the check.
  // Subsequent queries should use this to maintain consistency.
  SnapshotWindow window = 2;
}

// ObjectSet represents a set of objects of the same type.
// The IDs are stored as a serialized roaring bitmap for compression.
message ObjectSet {
  string object_type = 1;
  // Serialized roaring bitmap of object IDs.
  bytes object_ids = 2;
}

// BatchCheckRelationRequest checks if a subject has a relation on any of multiple objects.
// Objects are grouped by type in ObjectSets with compressed bitmap IDs.
message BatchCheckRelationRequest {
  string subject_type = 1;
  uint32 subject_id = 2;
  // Objects to check, grouped by type. Each ObjectSet contains a bitmap of IDs.
  repeated ObjectSet objects = 3;
  string relation = 4;
  SnapshotWindow window = 5;
  repeated VisitedNode visited = 6;
}

// BatchCheckRelationResponse is the result of a batch relation check.
message BatchCheckRelationResponse {
  // allowed is true if the subject has the relation on ANY of the objects.
  bool allowed = 1;
  // window is the narrowed snapshot window after the check.
  SnapshotWindow window = 2;
}

